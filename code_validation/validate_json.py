import llm_setup
import llm_parse
import json

#from request_llm import user_message, user_message, validation_user_message, validation_system_message_step_1


def validate(json_filename, user_message, validation_user_message, validation_system_message_step_1):
    from knowledge_base.system_specific import ELEMENTS_IN_SYSTEM
    json_content = ""

    # Using the JSON generated by the first LLM, we make a summary of actions on objects in order to try to estimate their final state
    elements= {}
    for each in ELEMENTS_IN_SYSTEM.split("\n"):
        temp = each.replace(" - ","")
        temp=temp.lower()

        if temp.replace(" ",""):
            elements[temp]={
                "actions": []
            }

    with open(json_filename,"r") as f:
        json_content=f.read()
    
    parsed_json_content = json.loads(json_content)

    for each_task in parsed_json_content["TASKS"]:
        if any(substring in each_task["NAME"].lower() for substring in elements):
            if "moverobot" not in each_task["SKILL"].lower():
                element_name=next((substring for substring in elements.keys() if substring in each_task["NAME"].lower()), None)
                elements[element_name]["actions"].append(each_task["NAME"])

    json_for_validation = {
        "MISSION_NAME": parsed_json_content["MISSION_NAME"],
        "ELEMENT_INFO": elements
    }

    #print (json_for_validation)

    # We'll use this new structure, where we identify objects used in our scenario and actions performed on them
    validation_user_message = validation_user_message.replace("%JSON%", json.dumps(json_for_validation, indent=2))

    # First loop: think about final states of different elements
    first_validation=llm_parse.parse_request(validation_user_message, system_message=validation_system_message_step_1)
    #print ("________________________________________")
    #print (first_validation)
    #print ("________________________________________")

    second_validation=llm_parse.parse_request("Write a short summary using bullet points where you describe the final state of all elements described in the provided JSON: %s" %(json.dumps(first_validation)), system_message="Read and intepret the JSON and generate a detailed answer", response_format="text" )

    #print (second_validation)
    
    # Second loop: check if this is what the user wanted
    final_validation_user="""
    Initially, the user indicated the next specification (between ________):
    USER SPECIFICATION: ________
    %USER_SPEC%
    ________

    Check if this information for the system's final state is acceptable (For the validation, ignore final state of objects whose final state was not explicitly specified by the user. Don't consider initial states in your analysis):
    ACHIEVED FINAL STATE: ________
    %FINAL_STATE%
    ________

    In the JSON, check the next fields:
        - FINAL_STATE_OBJECTS: a dict of JSON objects, where they 'key' is the name of the object that received each action in the tasks, and the value indicates the final state of the object (name of the final state of the object which is a combination of its state and location, as for example: "closed", "sliced and toasted", "open", "sliced in the fridge", etc)
        - ALL_ACTIONS_ON_OBJECTS: a dict of JSON objects, where they 'key' is the name of the object and the value is an array of all consecutive actions executed in the object
        - DESIRED_FINAL_STATE_OF_OBJECTS: considering the user specification, a dict of JSON objects mentioned by the user, where they 'key' is the name of the objects and the value is the final state indicated by the user.


    """
    final_validation_user=final_validation_user.replace("%USER_SPEC%", user_message)
    final_validation_user=final_validation_user.replace("%FINAL_STATE%",  second_validation)

    final_validation_system = """
      Check if the ACHIEVED FINAL STATE matches what the user request, and pay special attention to user requirements about how the system should be as as final state.

      The output of your analysis will be another JSON object with the following format:
        - MISSION_NAME: name of the JSON you analyzed (which is contained in the 'MISSION_NAME' of the validated JSON)
        - SUCCESS: a boolean ("true" or "false" depending on your validation process)
        - REVISED_ELEMENTS: an array indicating all elements that were considered in the analysis.
        - INFO: if everything is correct should contain the text "everything correct". If not, it should explain why the validation was not succesfull.

        Your output should only show a single JSON object, without extra explanations or characters. Just return a single JSON object.
    """


    final_validation=llm_parse.parse_request(final_validation_user, system_message=final_validation_system)

    #print ("=============================")
    

    return final_validation
